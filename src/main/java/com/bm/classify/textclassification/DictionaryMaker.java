package com.bm.classify.textclassification;import org.apache.log4j.Logger;import java.util.Iterator;import java.util.SortedMap;import java.util.TreeMap;/** * Baut eus einer menge von texten ein dictionary auf. Alternativ kann ein dictionary auch geladen werden. * * @author Daniel Wiese * @since 21.07.2006 */public class DictionaryMaker {	public static final int MAX_TERM_LENGTH = 50000;	// ~ Instance/static variables .............................................	private static final Logger log = Logger.getLogger(DictionaryMaker.class);	private final TermExtractor extractor;	private int dokumentCount = 0;	private SortedMap<String, Integer> termsAndIDF;	/**	 * Constructor.	 */	public DictionaryMaker() {		extractor = new TermExtractor();		dokumentCount = 0;		termsAndIDF = new TreeMap<String, Integer>();	}	/**	 * Anzahl der eingefuegten Dokumente.	 *	 * @return - die Anzahl der eingefuegten Dokumente	 */	public int getAnzahlDokumente() {		return dokumentCount;	}	/**	 * Gibt das Diationary in aktuellen Zusatand zur�ck. Und zwer den term und die absolute haufigkeit im gesammten	 * dokumentenstamm.	 *	 * @return - das dictionary	 */	public SortedMap<String, Integer> getTermsAndIDF() {		return termsAndIDF;	}	/**	 * Loescht alle internen Daten.	 */	public void clear() {		this.termsAndIDF = new TreeMap<String, Integer>();		this.dokumentCount = 0;	}	/**	 * Analyisert ein Dokumenent und fuegt es in das zu erzeugende Dictionary ein.	 *	 * @param dokument       der Text - das dokument	 * @param removeHtmlTags true entfernt html tags	 */	public void insertDokument(String dokument, boolean removeHtmlTags) {		try {			SortedMap<String, Integer> erg = extractor.getTermsAndFrequencies(dokument, removeHtmlTags).getSortedMap();			// Nur etwas tun, wenn nicht leer			if (erg.size() > 0) {				dokumentCount++;				if (dokumentCount % 5000 == 0) {					log.debug("Dokument (" + this.getAnzahlDokumente()							+ ") eingefuegt, DictionarySize = " + this.termsAndIDF.size());				}				Iterator<String> iter = erg.keySet().iterator();				while (iter.hasNext()) {					String term = iter.next();					// Wenn nicht vorhanden, anlegen					if (!termsAndIDF.containsKey(term)) {						if (term.length() > MAX_TERM_LENGTH) {							log.debug("Der Term " + term + " ist mit " + term.length()									+ " haufiger als erlaubt (" + MAX_TERM_LENGTH + ")");							continue;						} else {							termsAndIDF.put(term, erg.get(term));						}					} else {						int idf = termsAndIDF.get(term);						// Zaehler um eins rauf						termsAndIDF.put(term, (idf + erg.get(term)));					}				} // end while			} // end if		} catch (Exception e) {			log.error("Fehler beim Einf�gen eine Dokumentes (" + getAnzahlDokumente() + ")", e);		}	} // end method}