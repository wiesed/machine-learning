package com.bm.classify.textclassification;import org.apache.log4j.Logger;import org.apache.lucene.analysis.Analyzer;import org.apache.lucene.analysis.PorterStemFilter;import org.apache.lucene.analysis.Token;import org.apache.lucene.analysis.TokenStream;import org.apache.lucene.analysis.standard.StandardAnalyzer;import org.apache.lucene.analysis.standard.StandardTokenizerConstants;import org.jsoup.Jsoup;import java.io.StringReader;import java.util.StringTokenizer;import java.util.TreeMap;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Extrahiert die Terme aus einem Text. Hiefuer wird das analysepaket lucene * verwendet. * * @author Daniel Wiese * @since 21.07.2006 */public class TermExtractor {	static final String XETRA_DELIMITER = "AAAXETRAPLATZHALTERAAA";	static final String JAHR_DELIMITER = "AAAJAHRAAA";	static final String ZAHL_DELIM = "AAANumberAAA";	static final String FLOATINGZAHL_DELIM = "AAAFloatingNumberAAA";	private static final Logger log = Logger.getLogger(TermExtractor.class);	private static final String[] ACRONYM_DELIM = {"<Acronym>"};	private static final String[] COMPANY_DELIM = {"<Company>"};	private static final String[] HOST_DELIM = {"<Host>"};	private static final String[] EMAIL_DELIM = {"<Email>"};	private static final String STRING_JAHR = "(20\\d{2})|(19\\d{2})";	private static final Pattern PATTERN_JAHR = Pattern.compile("\\s" + STRING_JAHR + "\\s");	private static final Pattern PATTERN_EURO = Pattern.compile("â‚¬");	private static final Pattern PATTERN_PROZENT = Pattern.compile("%");	private static final Pattern PATTERN_DOLLAR = Pattern.compile("\\$");	private static final Pattern PATTERN_ISIN = Pattern.compile("(\\w{2})(\\d{10})");	private static final Pattern PATTERN_WKN = Pattern.compile("(\\d{6})");	private static final Pattern PATTERN_ZAHL = Pattern.compile("(\\d+)");	private static final Pattern PATTERN_DECIMAL_ZAHL = Pattern.compile("(\\d*)(\\.|\\,)(\\d+)");	private static final Pattern PATTERN_XETRA_STOCK = Pattern			.compile("(\\s)([A-Z])([A-Z]|[a-z]|\\.|\\-)+(\\sAG)*(\\s)\\((Xetra:)");	/**	 * Constructor.	 */	public TermExtractor() {	}	/**	 * Spaltet einen text in seine Terme mit haufigkeiten auf.	 *	 * @param text der Text.	 * @return TermSet mit den Term (woertern) und Frequencies	 */	public TermSet getTermsAndFrequencies(final String text, boolean removeHtmlTags) throws Exception {		return getTermsAndFrequencies(text, false, removeHtmlTags, 1);	}	/**	 * Spaltet einen text in seine Terme mit haufigkeiten auf.	 *	 * @param _text           der Text	 * @param englishStemming true wenn englisches stemming an sein soll.	 * @param weight          -	 *                        das gewicht.	 * @return TermSet mit den Term (woertern) und Frequencies	 */	public TermSet getTermsAndFrequencies(final String _text, final boolean englishStemming, boolean removeHtmlTags,										  int weight) throws Exception {		String text;		// Preprocessing		if (removeHtmlTags) {			text = Jsoup.parse(_text).text();			text = doPrecrocessing(text);		} else {			text = doPrecrocessing(_text);		}		final TreeMap<String, Integer> back = new TreeMap<String, Integer>();		if (text != null) {			// den standard analyser verwenden			Analyzer an = new StandardAnalyzer();			TokenStream stream = an.tokenStream("", new StringReader(text.trim()));			// wenn porter, dann PorterFiler einsetzen			stream = (englishStemming) ? new PorterStemFilter(stream) : stream;			Token tok = null;			do {				tok = stream.next();				if (tok != null) {					final String[] element = this.calculateElement(tok);					if (element != null) {						for (int i = 0; i < element.length; i++) {							String aktTerm = element[i];							this.tokenizeWhitespaceAndInsert(back, aktTerm);						}					}				}			} while (tok != null);			stream.close();		}		return new TermSet(back, weight);	}	private String preprocessString(Matcher macher, String string, String delim) {		StringBuilder builder = new StringBuilder();		boolean found = false;		int lastPos = 0;		while (macher.find()) {			builder.append(string.substring(lastPos, macher.start()));			builder.append(" ").append(delim).append(" ");			lastPos = macher.end();			found = true;		}		if (found) {			if (lastPos < string.length()) {				builder.append(string.substring(lastPos, string.length()));			}			return builder.toString();		} else {			return string;		}	}	private String doPrecrocessing(final String _text) {		String text = preprocessString(PATTERN_XETRA_STOCK.matcher(_text), _text, XETRA_DELIMITER);		text = preprocessString(PATTERN_DOLLAR.matcher(text), text, "Dollar");		text = preprocessString(PATTERN_EURO.matcher(text), text, "Euro");		text = preprocessString(PATTERN_PROZENT.matcher(text), text, "Prozent");		text = preprocessString(PATTERN_JAHR.matcher(text), text, JAHR_DELIMITER);		text = preprocessString(PATTERN_DECIMAL_ZAHL.matcher(text), text, FLOATINGZAHL_DELIM);		text = preprocessString(PATTERN_ZAHL.matcher(text), text, ZAHL_DELIM);		return text;	}	/**	 * Testet den Typ des Tokens.	 *	 * @param tok das Aktuelle token	 * @return null, wenn das Token nicht aufgenommen werden soll. Sonst ein	 * string array falls das token aufgespalten wurde.	 */	private String[] calculateElement(final Token tok) {		final String back = tok.termText();		final String type = tok.type();		final String[] defaultReturnValue = new String[1];		// Patterns		defaultReturnValue[0] = this.convertSymbols(back);		//defaultReturnValue[0] = this.convertZahlen(defaultReturnValue[0]);		if (type == null || back == null) {			return null;		} else if (tok.type().equals(				StandardTokenizerConstants.tokenImage[StandardTokenizerConstants.ALPHANUM])) {			return defaultReturnValue;		} else if (tok.type().equals(				StandardTokenizerConstants.tokenImage[StandardTokenizerConstants.APOSTROPHE])) {			return defaultReturnValue;		} else if (tok.type().equals(				StandardTokenizerConstants.tokenImage[StandardTokenizerConstants.ACRONYM])) {			String[] temp = new String[2];			temp[0] = ACRONYM_DELIM[0];			temp[1] = defaultReturnValue[0];			return temp;		} else if (tok.type().equals(				StandardTokenizerConstants.tokenImage[StandardTokenizerConstants.COMPANY])) {			String[] temp = new String[2];			temp[0] = COMPANY_DELIM[0];			temp[1] = defaultReturnValue[0];			return temp;		} else if (tok.type().equals(				StandardTokenizerConstants.tokenImage[StandardTokenizerConstants.EMAIL])) {			return EMAIL_DELIM;		} else if (tok.type().equals(				StandardTokenizerConstants.tokenImage[StandardTokenizerConstants.HOST])) {			String[] temp = new String[2];			temp[0] = HOST_DELIM[0];			temp[1] = defaultReturnValue[0];			return temp;		} else {			if (log.isDebugEnabled()) {				log.debug("calculateElement() Das Token '" + back + "' wurde nicht (" + type						+ ") erkannt.");			}			return null;		}	}	private String convertSymbols(String back) {		if (PATTERN_ISIN.matcher(back).matches()) {			return "<ISIN>";		} else if (PATTERN_WKN.matcher(back).matches()) {			return "<WKN>";		} else {			return back;		}	}//	/**//	 *//	 * Wandelt Zahlen in einen Platzhalter um//	 *//	 * @param toConvert//	 *//	 * @return den processierten String//	 *//	 */////	private String convertZahlen(final String toConvert) {//		boolean back = true;//		for (int i = 0; i < toConvert.length(); i++) {//			if (!(toConvert.charAt(i) >= '0' && toConvert.charAt(i) <= '9')) {//				back = false;//			} // end if//		} // end for////		String result  =  (back) ? ZAHL_DELIM[0] : toConvert;//		result = (back) ? ZAHL_DELIM[0] : toConvert;////	}	private void tokenizeWhitespaceAndInsert(final TreeMap<String, Integer> back, final String term) {		StringTokenizer tok = new StringTokenizer(term, " ");		while (tok.hasMoreTokens()) {			String aktTerm = tok.nextToken().trim();			// nur einfuegen, wenn nicht leer			if (!aktTerm.equals("")) {				if (!back.containsKey(aktTerm)) {					back.put(aktTerm, new Integer(0));				}				// Anzahl um 1 erhoehen				final Integer oldValue = back.get(aktTerm);				back.put(aktTerm, new Integer(oldValue.intValue() + 1));			}		}	}}