package com.bm.classify.textclassification;import com.bm.classify.core.helper.LinearHyperpaneJson;import com.bm.common.util.JacksonProvider;import com.bm.data.bo.ai.ITermFrequency;import com.fasterxml.jackson.core.JsonProcessingException;import com.google.common.base.Charsets;import com.google.common.io.Resources;import org.apache.log4j.Logger;import java.io.IOException;import java.io.Serializable;import java.util.*;/** * Woertbuch fuer die BagOfWordDarstellung, kennt idf. * * @author Daniel Wiese * @since 05.08.2006 */public class Dictionary implements Serializable {	// ~ Instance/static variables .............................................	private static final long serialVersionUID = 1L;	private static final Logger log = Logger.getLogger(Dictionary.class);	private final int anzahlDokumente;	private final List<String> terms;	private final List<Integer> termsDf;	private final List<List<Integer>> termsCdf ;	private final Map<String, Integer> termsMapPosition;	/**	 * Constructor.	 *	 * @param dictionaryAsJSON -	 *                           das JSON Serialiserte Disctionary	 */	public Dictionary(String dictionaryAsJSON){		try {			final String hyperpaneAsJson =					Resources.toString(Resources.getResource("dictionary/" + dictionaryAsJSON), Charsets.UTF_8);			final DictionaryJson dictJson = JacksonProvider.getMapper().readValue(hyperpaneAsJson,					DictionaryJson.class);			this.anzahlDokumente = dictJson.getAnzahlDokumente();			this.terms = dictJson.getTerms();			this.termsDf = dictJson.getTermsDf();			this.termsCdf = dictJson.getTermsCdf();			this.termsMapPosition = dictJson.getTermsMapPosition();		} catch (IOException e) {			throw new RuntimeException("fehlr bei der JSON de-serialiserung", e);		}	}	/**	 * Constructor.	 *	 * @param temsAndFrequencies -	 *                           liste mit termen und den zugeheorigen termhaufigkeiten	 * @param allDocumentCount   -	 *                           anzahl aller dokumente	 */	public Dictionary(List<ITermFrequency> temsAndFrequencies, int allDocumentCount) {		// terme sortieren damit die reihenfolge stets gelich ist		this.termsCdf = new ArrayList<List<Integer>>();		this.termsMapPosition = new HashMap<String, Integer>();		Collections.sort(temsAndFrequencies);		// Initialisierung		this.terms = new ArrayList<String>();		this.termsDf = new ArrayList<Integer>();		for (ITermFrequency akt : temsAndFrequencies) {			terms.add(akt.getTerm());			termsDf.add(akt.getHaufigkeit());		}		if (terms.size() % 50000 == 0) {			log.debug("Es wurden bereits " + terms.size() + " terme geladen.");		}		this.anzahlDokumente = allDocumentCount;		this.init();		log.debug("Dictionary geladen. Eintraege = #" + this.terms.size() + ", Dokumente = "				+ this.anzahlDokumente);	} // end constructor	/**	 * Liefert die anzahl aller dokumente im dictionary.	 *	 * @return - anzahl aller dokumente im dictionary	 * @author Daniel Wiese	 * @since 05.08.2006	 */	public int getAnzahlDokumente() {		return this.anzahlDokumente;	}	/**	 * Anzahl der Terme.	 *	 * @return Anzahl der Terms	 */	public int getDictonarySize() {		return this.terms.size();	}	public String asJson() {		try {			final DictionaryJson linearHyperpaneJson =					new DictionaryJson(this.anzahlDokumente, this.terms, this.termsDf, this.termsCdf, this.termsMapPosition);			return JacksonProvider.getMapper().writeValueAsString(linearHyperpaneJson);		} catch (JsonProcessingException e) {			throw new RuntimeException("Fehler bei der JSON Serialiserung");		}	}	/**	 * CDF= maxCF/DF, DF bezieht sich auf den aktuellen term.	 *	 * @param pos -	 *            die position im dictionary	 * @return CDF= maxCF/DF, DF bezieht sich auf den aktuellen term.	 * @author Daniel Wiese	 * @since 05.08.2006	 */	public double getCDF(final int pos) {		if (pos <= 0 || pos >= termsDf.size()) {			return 0;		} else {			// Berechne CDF = maxCF/DF			int maxFreq = 0;			for (List<Integer> ctermsDf : termsCdf) {				if (ctermsDf.get(pos) > maxFreq) {					maxFreq = ctermsDf.get(pos);				}			}			return (maxFreq / termsDf.get(pos));		}	}	/**	 * Gibt IDF zurueck (inverse document frequency).	 *	 * @param pos -	 *            die position im (dictionary) vector	 * @return idf (inverse document frequency)	 */	public double getIDF(final int pos) {		if (pos < 0 || pos >= termsDf.size()) {			return 0;		} else {			// Berechne IDF = log(|D|/DF(term)) // Log ist zur Basis e!!			double back = (Math.log((this.anzahlDokumente)					/ (termsDf.get(pos).doubleValue())));			return back;		}	}	/**	 * Liefert die document frequency.	 *	 * @param pos -	 *            die posotion im vecor	 * @return - die posotion im vector.	 * @author Daniel Wiese	 * @since 05.08.2006	 */	public double getDF(final int pos) {		return termsDf.get(pos).doubleValue();	}	/**	 * Gibt IDF nach Term zurueck.	 *	 * @param term -	 *             der gesuchte term.	 * @return null, wenn nicht gefunden	 */	public double getIDF(final String term) {		return this.getIDF(this.getPosition(term).intValue());	}	/**	 * Gibt die Position eines Term zurueck, wenn er im Dictonray ist, sonst	 * <code>null</code>.	 *	 * @param term -	 *             der gesuchte term.	 * @return null, wenn nicht im Dictonary	 */	public Integer getPosition(final String term) {		return this.termsMapPosition.get(term);	}	/**	 * Liefert den Term an einer bestimmten posion.	 *	 * @param pos -	 *            die position im Term.	 * @return - den term an der position	 * @author Daniel Wiese	 * @since 05.08.2006	 */	public String getTerm(int pos) {		if (pos < terms.size() && pos >= 0) {			return this.terms.get(pos);		} else {			return "<not found>";		}	}	/**	 * Prueft, ob der Term im Dictonary ist.	 *	 * @param term -	 *             der name des terms.	 * @return true, wenn im Dictonary	 */	public boolean isTermInDictionary(final String term) {		return this.termsMapPosition.containsKey(term);	}	/**	 * Initialisiert das Dictionary.	 */	private void init() {		for (int i = 0; i < terms.size(); i++) {			final String term = terms.get(i);			this.termsMapPosition.put(term, new Integer(i));		} // end for	} // end init}