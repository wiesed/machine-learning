package com.bm.classify.textclassification;import java.util.HashMap;import java.util.Iterator;import java.util.TreeSet;import com.bm.classify.core.SVMFeatureSet;import com.bm.common.enums.Label;import com.bm.train.Normalizer;/** * 2Back-of-Words, der Wortvektor. Kennt seinen Label. *  * @author Daniel Wiese * @since 05.08.2006 */public class BagOfWords {	private Dictionary dict;	private final HashMap<Integer, Integer> freq = new HashMap<Integer, Integer>();	private final HashMap<Integer, Double> tfidf = new HashMap<Integer, Double>();	private Label label = Label.UNLABLED;	/**	 * Erzeugt den Vector.	 * 	 * @param _dict --	 *            das Dictonary	 * @param doc --	 *            das Doucment (als term set repraesentiert)	 */	public BagOfWords(final Dictionary _dict, final TermSet doc) {		this.dict = _dict;		this.addTermSet(doc);	} // end constructor	/**	 * Gibt die Termfrequency fuer das Aktuelle Wort zurï¿½ck.	 * 	 * @param pos -	 *            die position des wortes	 * @return - die term frequency.	 */	public int getTF(int pos) {		if (!freq.containsKey(pos)) {			return 0;		} else {			return freq.get(pos);		}	}	/**	 * Liefert die anzahl der terme zurueck.	 * 	 * @author Daniel Wiese	 * @since 05.08.2006	 * @return - liefert die anzahl der terme zurueck.	 */	public int getSize() {		return this.freq.keySet().size();	}	/**	 * Returns the label.	 * 	 * @return Returns the label.	 */	public Label getLabel() {		return this.label;	}	/**	 * Sets the label.	 * 	 * @param label	 *            The label to set.	 */	public void setLabel(Label label) {		this.label = label;	}	/**	 * Fuegt eine TermSet hinzu. Ein term set ist z.B. ein text einer nachricht.	 * 	 * @param doc -	 *            das term set.	 */	private void addTermSet(TermSet doc) {		Iterator<String> iter = doc.getSortedMap().keySet().iterator();		final int weight = (doc.getWeight()) > 0 ? doc.getWeight() : 0;		while (iter.hasNext()) {			final String key = iter.next();			final Integer anz = doc.getSortedMap().get(key);			if (dict.isTermInDictionary(key)) {				final Integer pos = dict.getPosition(key);				// 0 reinpacken, wenn nicht vorhanden;				if (!freq.containsKey(pos)) {					freq.put(pos, new Integer(0));				}				// Alten Werten herausnehmen				Integer old = freq.get(pos);				// Neuen Wert berechen				final int neuerWert = old.intValue()						+ (anz.intValue() * weight);				// Neuen Wert eintragen				freq.put(pos, new Integer(neuerWert));				// TFIDF berechnen (TF*IDF)				tfidf.put(pos, new Double(neuerWert						* dict.getIDF(pos.intValue())));			} // end if - in Dict		} // end while	}	/**	 * Druckt den BOW fuer die mySVM aus. <br> - (false, false): Keine	 * Normalisirung<br> - (true, false): L1 Normalisirung<br> - (true, true):	 * L2 Normalisirung<br>	 * 	 * @author Daniel Wiese	 * @since 05.08.2006	 * @param normalise -	 *            ob die L1 oder die L2 normalisierung angewendet werden soll	 * @param isL2 -	 *            die L2 normalisrsirung anwenden.	 * @return - der vektor fuer die SVM	 */	public String printToSVMLightTFIDF(boolean normalise, boolean isL2) {		final StringBuffer back = new StringBuffer();		TreeSet<Integer> positions = new TreeSet<Integer>(this.freq.keySet());		Iterator<Integer> iter = positions.iterator();		double normalizeFaktor = (normalise) ? (isL2) ? this				.calculateL2NormaliseDividentTFIDF() : this				.calculateL1NormaliseDividentTFIDF() : 1;		back.append(this.labelToString());		while (iter.hasNext()) {			Integer pos = iter.next();			double tfidfAkt = (tfidf.get(pos)).doubleValue();			if (tfidfAkt > 0) {				// the position is 0 based> the SVM 1 based				back.append(pos.intValue() + 1).append(":");				back						.append((normalise) ? tfidfAkt / normalizeFaktor								: tfidfAkt);				back.append(" ");			} // end if		} // end for		return back.toString();	}	/**	 * Druckt den BOW fuer die mySVM aus. <br> - (false, false): Keine	 * Normalisirung<br> - (true, false): L1 Normalisirung<br> - (true, true):	 * L2 Normalisirung<br>	 * 	 * @author Daniel Wiese	 * @since 05.08.2006	 * @param normalise -	 *            ob die L1 oder die L2 normalisierung angewendet werden soll	 * @param isL2 -	 *            die L2 normalisrsirung anwenden.	 * @return - der vektor fuer die SVM	 */	public SVMFeatureSet toSVMFeatureSetTFIDF(boolean normalise, boolean isL2) {		final SVMFeatureSet back = new SVMFeatureSet(this.label);		TreeSet<Integer> positions = new TreeSet<Integer>(this.freq.keySet());		Iterator<Integer> iter = positions.iterator();		// Wenn nicht normalisiert wird		double normalizeFaktor = 1;		if (normalise) {			normalizeFaktor = (isL2) ? this.calculateL2NormaliseDividentTFIDF()					: this.calculateL1NormaliseDividentTFIDF();		}		while (iter.hasNext()) {			Integer pos = iter.next();			double tfidfAkt = (tfidf.get(pos)).doubleValue();			if (tfidfAkt > 0) {				final double value = (normalise) ? tfidfAkt / normalizeFaktor						: tfidfAkt;				// the position is 0 based> the SVM 1 based				back.appendFeature(value, pos.intValue() + 1);			} // end if		} // end for		return back;	}	/**	 * Die to string ausgabe.	 * 	 * @return - die to string ausgabe	 * @author Daniel Wiese	 * @since 05.08.2006	 * @see java.lang.Object#toString()	 */	public String toString() {		return "[#" + this.freq.keySet().size() + "]";	}	/**	 * Normaliserungszahl nach L1 berechnen	 */	private double calculateL1NormaliseDividentTFIDF() {		final Normalizer normalizer = new Normalizer();		return normalizer.calculateL1NormaliseDivident(this.tfidf);	}	/**	 * Normaliserungszahl nach L2 berechnen	 */	private double calculateL2NormaliseDividentTFIDF() {		final Normalizer normalizer = new Normalizer();		return normalizer.calculateL2NormaliseDivident(this.tfidf);	}	/**	 * Konvertiert den label in einen string.	 * 	 */	private String labelToString() {		final StringBuilder sb = new StringBuilder();		switch (this.label) {		case POSITIVE:			sb.append("+1");			break;		case NEGATIVE:			sb.append("-1");			break;		default:			sb.append("0");		}		sb.append(" ");		return sb.toString();	}}